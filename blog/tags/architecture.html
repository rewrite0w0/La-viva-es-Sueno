<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-tags-post-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/La-viva-es-Sueno/blog/rss.xml" title="rewrite0w0&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/La-viva-es-Sueno/blog/atom.xml" title="rewrite0w0&#39;s blog Atom Feed"><title data-rh="true">5 posts tagged with &quot;architecture&quot; | rewrite0w0&#x27;s blog</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://rewrite0w0.github.io/La-viva-es-Sueno/blog/tags/architecture"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" property="og:title" content="5 posts tagged with &quot;architecture&quot; | rewrite0w0&#x27;s blog"><meta data-rh="true" name="docusaurus_tag" content="blog_tags_posts"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_tags_posts"><link data-rh="true" rel="icon" href="/La-viva-es-Sueno/img/rw.ico"><link data-rh="true" rel="canonical" href="https://rewrite0w0.github.io/La-viva-es-Sueno/blog/tags/architecture"><link data-rh="true" rel="alternate" href="https://rewrite0w0.github.io/La-viva-es-Sueno/blog/tags/architecture" hreflang="en"><link data-rh="true" rel="alternate" href="https://rewrite0w0.github.io/La-viva-es-Sueno/blog/tags/architecture" hreflang="x-default"><link rel="stylesheet" href="/La-viva-es-Sueno/assets/css/styles.fa6ac47c.css">
<link rel="preload" href="/La-viva-es-Sueno/assets/js/runtime~main.fccf6e12.js" as="script">
<link rel="preload" href="/La-viva-es-Sueno/assets/js/main.2307e441.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/La-viva-es-Sueno/"><div class="navbar__logo"><img src="/La-viva-es-Sueno/img/rw.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/La-viva-es-Sueno/img/rw.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate"></b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/La-viva-es-Sueno/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/rewrite0w0/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-06-18-bye-ie">Internet Explorer와 만나고 싶어지면...</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-06-12-encouragement-of-type">타입을 권함</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-06-06-kimi-ni-wa-ima-kara-3jikan-de-kikai-application-wo">지금부터 3시간 안에 기계학습 Web 애플리케이션을 만들어보게</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-06-05-about-what-to-make">프로그래밍과 요리와 무엇인가 만드는 일</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-06-01-about-http1.1">HTTP/1.1를 조사했다.</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-23-nanno-tameni-tsukuru-ka-wakaran">뭘 만들어야할지 몰라 푸념했는데 PM이 도와준 이야기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-19-2022-first-quarter-programming-ranking">2022년 일사분기 프로그래밍 언어 랭킹</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-18-javascript-no-this-wa-4-syurui">JavaScript의 this는 4종류??</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-16-realize-flutter3">flutter 3 등장</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-15-programming-language-wo-atarashiku-oboetai-toki-ni-tamesu-koto-7sen">프로그래밍 언어를 새롭게 배우려할 때 시도하는 행동 7가지</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-13-a-lot-of-OOOO-domain">ㅇㅇ 주도 설계 개발이 너무 많다.</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-11-bokura-wo-shiboru-nodejs-and-reply">우리를 조여오는 Node.js의 저주 그리고 Re:우리를 조여오는 Node.js의 저주 - 혹은 왜 TypeScript 이 외에 적당한 선택이 없는가</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-10-github-2fa-2023">github, 코드 제공 모든 유저에게 2단계 인증(2FA) 의무화를 2023년 말까지</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-09-npm-scripts-wo-kaku-doki-no-tekuse">npm-scripts를 적을 때 습관</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-07-elden-ring-kara-mananda-programming">엘든 링에서 배우는 프로그래밍 학습에 필요한 7가지</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-06-atomic-design-wo-wakkata-tsumori-ni-naru">Atomic Design 아는 척하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-05-anata-no-web-service-no-zeijakusei-wo-hakkensha-kara-oshiete-morau-houhou-rfc9116">당신의 web 서비스 취약성을 발견자에게 듣기위한 방법 - RFC9116</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-04-github-disabled-git-protocol">GitHub가 git://를 무효화한 것에 대해</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-03-shinjin-no-uchi-koredaka-wa-naoshite-hoshii-koto">신입 때 바로 잡았으면 하는 것</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-05-01-flux-and-react">flux와 가상 DOM에 대해서</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-04-30-How-your-familiar-JavaScript-coding-techniques-will-change-in-the-near-future">JavaScript 진화에 변화할 코딩 습관</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-04-28-about-first-class-and-high-order-function">일급 객체와 고차 함수</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-04-28-supplementary-lessons-about-map">.map() 남용을 멈추자 보충</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-04-27-dependabot-no-settei-wo-minaoshitemita">Dependabot 설정을 둘러보았다.</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-04-24-blog-on-github-action">블로그에 github action 넣기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-04-24-source-ga-kara-no-nazo-no-site">소스가 비어있는 의문의 사이트 therickroll.com</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-04-23-record-of-eslint-prettier">eslint와 prettier 사용기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2022-04-23-record-of-github-action">github actions 사용기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/playwright-tutorial">Playwright 사용기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/commands-cheatsheet">자주 쓰는 명령어 목록</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/record-of-fzo">fzo 제작기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/confused-modules">모듈이 혼란스럽다.</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/difference-architecture-and-design">아키텍처와 디자인</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/understand-sakura-api">SAKURA API 이해하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/first-js-lib">라이브러리 만드는 과정 기록</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/stop-abusing-map">.map() 남용을 멈추자.</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/beginner-programmer-to-know-about-resource-50">모든 초보 프론트엔드 엔지니어가 읽었으면 하는 자료 50</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/mandara-and-programming">만다라로 프로그래밍</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/rakus-ddd">DDD 도입을 위해 한 것</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/rakus-frontend-build-tool-2021">프론트엔드 빌드 도구를 조사했다.</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/try-understand-csr-ssr-ssg-isr">(Next.js) CSR, SSR, SG(SSG), ISR가 모호한 당신을 위해 찬찬히 해설</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/2021-try-fullstack-nextjs">2021년은 fullstack next.js 원년이므로, 유망한 next.js 계열 프레임워크를 전부 체험했다.</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/image-csr-ssr-ssg-isr">도해 CSR, SSR, SG(SSG), ISR</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/think-about-personal-developement-architecture">개인개발 / 스타트업이 선택하면 좋을 최강의 아키텍처에 대한 생각</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/change-array-by-copy-stage3">Change Array by Copy Status Stage3</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/keep-truth-acting">프로그래밍 미경험자가 3개월만에 외자 IT 엔지니어가 되서 연봉 2억에 달하는 로드맵</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/array-sum-array-is-weird">JS에서 [1, 2, 3]+[4, 5, 6]은 왜 &quot;1,2,34,5,6&quot;인가?</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/imasara-react-v18">이제와서 알아보는 React v18</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/safe-react-hooks-policy">보수하기 쉬운 React Hooks 코드 방침</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/unit-test-no-susume">유닛테스트를 권함</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/you-can-define-and-design-project">요건정의 ~ 시스템 설계까지 할 수 있는 인재가 되는 글</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/ES2022-march">ES2022 3월 후보판을 보자</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/React-no-unit-test-2021">React 유닛테스트 2021</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/jibun-no-javascript-unit-test-kaki-kata">(자신만의) JavaScript 유닛테스트 작성 방법</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/react-v18.0">React v18.0 (2022-05-xx 완료)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/you-dont-need-classes">You don&#x27;t need classes</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/you-dont-need-if">You don&#x27;t need if</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/you-dont-need-mutation">You don&#x27;t need mutation</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/you-dont-need-null">You don&#x27;t need null</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/md-in-github">markdown 메모</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/setting-vsc-and-git">vsc 설치후 바로하는 세팅</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/evilcodeinpeacenotwar-and-node-ipc">peacenotwar, node-ipc에 악의적 코드를 메인테이너가 넣었다</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/MS-for-Startups-Founders-Hub">Microsoft for Startups Founders Hub</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/imasararecoil">(TS) 이제와서 묻기 애매한 recoil</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/try-make-myLint">나만의 ESLint 규칙을 만들어보았다.</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/perhaps-TypeScript-in-Browser">TypeScript가 브라우저로 들어올지도 모릅니다.</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/10times-read-react-document">reactHook을 10번 읽고서</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/somo-somo-npmkara-Wakaranai">애초에 npm부터 뭔지 모르겠다.</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/yappari-webpack-ga-wakaranai-episode2">역시 webpack이 뭔지 모르겠다. (에피소드2)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/follow-webpack-guides">webpack 메모 (guides)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/translate-list-without-blog">블로그에 없는 글</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/follow-webpack-concepts">webpack 메모 (concepts)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/yappari-webpack-ga-wakaranai-episode1">역시 webpack이 뭔지 모르겠다. (에피소드1)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/think-about-you-dont-need-loop">You Don&#x27;t Need Loops 번역 후, 감상</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/javascript-secrets">JS문서를 읽으며 느낀 비기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/functional-programming-is-style">함수형은 프로그래밍 스타일</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/react18-5min">React 18 대비하려면 어떻게 해야할까? 5분만에 이해하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/the-mistakes-i-made-as-a-beginner-programmer">초보 프로그래머가 범하는 실수들(The Mistakes I Made As a Beginner Programmer)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/kenkyuu-wo-hajimaru-mae-ni-sittte-oite-hoshii-nanatsu-no-koto">연구하기 전에 알아두면 좋은 7가지</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/tracing-closure">클로저가 알고 싶어</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/engineer-no-rettoukan-tono-tsukiai-kata">엔지니어가 열등감과 마주하는 방법</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/34-JavaScript-Optimization-Techniques-to-Know-in-2021">34 JavaScript Optimization Techniques to Know in 2021</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/block-FLoC">Google Chrome이 권장하는 광고기술 FLoC 정리</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/La-viva-es-Sueno/blog/naze-haskell-wo-manabu-to-yoika">왜 Haskell을 배우는 것이 좋은가</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><header class="margin-bottom--xl"><h1>5 posts tagged with &quot;architecture&quot;</h1><a href="/La-viva-es-Sueno/blog/tags">View All Tags</a></header><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/La-viva-es-Sueno/blog/2022-05-13-a-lot-of-OOOO-domain">ㅇㅇ 주도 설계 개발이 너무 많다.</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2022-05-13T00:00:00.000Z" itemprop="datePublished">May 13, 2022</time> · <!-- -->12 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_sTYa"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/rewrite0w0" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">rewrite0w0</span></a></div><small class="avatar__subtitle" itemprop="description">JavaScript 개발자</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><blockquote><p><a href="https://qiita.com/muson0110/items/c15d6a0ba0582da204e1" target="_blank" rel="noopener noreferrer">글</a></p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="머릿말">머릿말<a class="hash-link" href="#머릿말" title="Direct link to heading">​</a></h2><p>안녕하세요 기술 글을 적는 것에서 도망치고 있는 무소입니다.</p><p>어째서인가 최근 &quot;<strong>ㅇㅇ주도개발</strong>&quot;이라는 말을 자주 듣습니다.</p><p>ㅇㅇ주도 개발이 너무 많은데, 의견 충돌 안 일어나나?생각해 시작한 글입니다.</p><p><strong>무엇을 축으로 주도하면 좋은가 애매한 문제</strong>입니다.</p><p>이 만큼 ㅇㅇ주도 개발이라는 말이 많은 것은 <strong>못난 자신을 좋은 DX로 밀어주기를 바라는 욕구의 구현이 아닐까? (구세주 사상적스러운)</strong> 이런 혼자만의 생각이 있었지만, <strong>이러한 상황에는 ㅇㅇ 주도 개발하면 좋다</strong> 느낌으로 정리하려합니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="유명한-주도개발-종류">유명한 주도개발 종류<a class="hash-link" href="#유명한-주도개발-종류" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="유저-기능-주도-개발fdd">유저 기능 주도 개발(FDD)<a class="hash-link" href="#유저-기능-주도-개발fdd" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="의미">의미:<a class="hash-link" href="#의미" title="Direct link to heading">​</a></h4><blockquote><p>FDD(Feature Driven Development)는 Jeff De Luca가 1997년 싱가폴 은행의 대규모 개발 프로젝트(50인, 15개월)을 위해 제안한 애자일 개발 프로세스입니다. feature는 고객 시점에서 작은 단위 기능 가치를 말합니다. FDD는 실전 경험있는 모범사례를 조합한 것으로 작동하는 소프트웨어를 짧은 간격으로 반복적 제공합니다.</p></blockquote><p><a href="https://www.sei-info.co.jp/framework/keyword/agile.html#fdd" target="_blank" rel="noopener noreferrer">인용</a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="어떨-때-사용하는가">어떨 때 사용하는가:<a class="hash-link" href="#어떨-때-사용하는가" title="Direct link to heading">​</a></h4><p>유저의 요구에 기반하지 않은 개발은 쓸데 없는 비용이 들 가능성이 높으므로, 유저가 바라는 기능을 기조로 개발을 진행할 때는 유저 기능 주도 개발입니다.</p><ul><li><p>사업화전 아이디어가 실제 이익을 내는가 불명이면서, 고객과 대화하며 기능 개발을 진행하고 싶은 경우</p></li><li><p>엔지니어 팀의 기술숙련도가 그다지 높지 않으므로 쓸모 없이 자잘하게 개발을 하고 싶은 경우</p></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="참조링크">참조링크:<a class="hash-link" href="#참조링크" title="Direct link to heading">​</a></h4><ul><li><a href="https://www.sei-info.co.jp/framework/keyword/agile.html" target="_blank" rel="noopener noreferrer">https://www.sei-info.co.jp/framework/keyword/agile.html</a></li><li><a href="https://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E6%A9%9F%E8%83%BD%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA" target="_blank" rel="noopener noreferrer">https://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E6%A9%9F%E8%83%BD%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA</a></li><li><a href="https://www.amazon.co.jp/dp/4274068560/ref=cm_sw_em_r_mt_dp_F136C0SBZ2X2MAB2N0B6" target="_blank" rel="noopener noreferrer">https://www.amazon.co.jp/dp/4274068560/ref=cm_sw_em_r_mt_dp_F136C0SBZ2X2MAB2N0B6</a></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="티켓-주도-개발">티켓 주도 개발<a class="hash-link" href="#티켓-주도-개발" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="의미-1">의미:<a class="hash-link" href="#의미-1" title="Direct link to heading">​</a></h4><blockquote><p>티켓 주도 개발(ticket-driven development; TiDD)는 프로그램 개발 방법의 하나로 작업을 나눠 BTS(Bug Tracking System) 티켓을 할당해 관리하는 개발스타일. 세세한 수정이 많은 종래의 개발에서 태어났지만, 애자일 개발과 친화성이 높아, 익스트림 프로그래밍을 시작해 애자일 개발에도 적용되어 있다.</p></blockquote><p><a href="https://ja.wikipedia.org/wiki/%E3%83%81%E3%82%B1%E3%83%83%E3%83%88%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA" target="_blank" rel="noopener noreferrer">인용</a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="어떨-때-사용하는가-1">어떨 때 사용하는가:<a class="hash-link" href="#어떨-때-사용하는가-1" title="Direct link to heading">​</a></h4><p>과거의 기능요구, 버그 수정 같은 것을 추적하는 것은 중요한 일입니다.</p><p>모든 개발은 기본 티켓 개발 주도 개발이어야 한다 생각합니다.</p><ul><li>이슈, 티켓을 기반으로 개발을 철처히 하는 것으로 문제/요구사항 출현 ~ 기능 구현 완료까지 모든 공정을 추적하고 싶은 경우</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="참조링크-1">참조링크:<a class="hash-link" href="#참조링크-1" title="Direct link to heading">​</a></h4><ul><li><a href="https://www.atlassian.com/ja/blog/tidd-part2" target="_blank" rel="noopener noreferrer">https://www.atlassian.com/ja/blog/tidd-part2</a></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="마감-시한-주도-개발">마감 시한 주도 개발<a class="hash-link" href="#마감-시한-주도-개발" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="의미-2">의미:<a class="hash-link" href="#의미-2" title="Direct link to heading">​</a></h4><blockquote><p>마감 시한이 아슬아슬할 때까지 개발을 하지 않고, 고객과 커뮤니케이션에 전념한다. 어떠한 행운도 이것보다 늦어지면 사단이 날 것 같을 때까지 와서, 개발을 개시한다. 이 단계에서 다음 고객의 일을 시작해서 자원 소비의 평균화한다. 마감 시한이 이미 지났다는 압박을 이용해서 개발을 진행하므로 마감 시한 주도 개발이라 한다.</p></blockquote><p><a href="https://ansaikuropedia.org/wiki/%E7%B7%A0%E3%82%81%E5%88%87%E3%82%8A%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA" target="_blank" rel="noopener noreferrer">인용</a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="어떨-때-사용하는가-2">어떨 때 사용하는가:<a class="hash-link" href="#어떨-때-사용하는가-2" title="Direct link to heading">​</a></h4><p>밈스러운 의미로 사용하는 것이 아닌가 싶지만 은근히 많은 사람에게 유효한 수단일지도 모릅니다.</p><p>어린 시절 여름 방학 숙제, 시험전 날 벼락치기 같은 것이 기억나실지도 모릅니다.</p><ul><li>시간을 철저하지 않은 엔지니어에게 마감 시한이라는 절대 조건을 줌으로 움직이게 할 수 있다.</li><li>마감 시한이 없으면 의욕이 없는 경우</li><li>압박을 받고 싶을 경우 혹은 그러한 성격</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="참조링크-2">참조링크:<a class="hash-link" href="#참조링크-2" title="Direct link to heading">​</a></h4><blockquote><p>마감 시한 주도 개발, &quot;나는 마감이 얼마 남았을 때 움직이는가&quot; 정확히 확인하지 않으면 효율적으로 일하지 못하므로 이를 의식하며 계획을 세워야 한다 - chokudai@AtCoder 사장 <a href="https://twitter.com/chokudai/status/505591480233119744?ref_src=twsrc%5Etfw" target="_blank" rel="noopener noreferrer">August 30, 2014</a></p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="도메인-주도-개발설계">도메인 주도 개발(설계)<a class="hash-link" href="#도메인-주도-개발설계" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="의미-3">의미:<a class="hash-link" href="#의미-3" title="Direct link to heading">​</a></h4><blockquote><p>도메인 주도 개발(domain-driven design, DDD)는 소프트웨어 설계 방법이며, &quot;복잡한 도메인 설계는, 모델 베이스로 해결할 것&quot;, &quot;대부분의 소프트웨어 프로젝트에는 시스템을 구현하기 위해 특정 기술이 아니며, 도메인 그 자체와 도메인의 로직에 집중할 것&quot;을 하는 것이다.</p></blockquote><p><a href="https://ja.wikipedia.org/wiki/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E9%A7%86%E5%8B%95%E8%A8%AD%E8%A8%88" target="_blank" rel="noopener noreferrer">인용</a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="어떨-때-사용하는가-3">어떨 때 사용하는가:<a class="hash-link" href="#어떨-때-사용하는가-3" title="Direct link to heading">​</a></h4><p>IT 엔지니어로 업계에 전직하고자 할 때, 공통적으로 활용할 수 있는 지식을 갖고 싶다면 제대로 도메인 주도 개발을 배워둬야 합니다.</p><ul><li>IT 아키텍처와 업계 독자의 도메인 지식을 어떻게 세워 올리는가 함께 애플리케이션을 설계/개발할 필요가 있을 때</li><li>과거 코드가 너무 거시기해서 도메인 주도 설계 기반으로 리팩토링을 하고 싶은 경우</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="참조링크-3">참조링크:<a class="hash-link" href="#참조링크-3" title="Direct link to heading">​</a></h4><ul><li><a href="https://www.amazon.co.jp/dp/479815072X/ref=cm_sw_em_r_mt_dp_QVR1VSSQAVYKMCRZMS6J?_encoding=UTF8&amp;psc=1" target="_blank" rel="noopener noreferrer">https://www.amazon.co.jp/dp/479815072X/ref=cm_sw_em_r_mt_dp_QVR1VSSQAVYKMCRZMS6J?_encoding=UTF8&amp;psc=1</a></li><li><a href="https://www.amazon.co.jp/dp/4798121967/ref=cm_sw_em_r_mt_dp_JCYEEPKX12NBHWSJKA13?_encoding=UTF8&amp;psc=1" target="_blank" rel="noopener noreferrer">https://www.amazon.co.jp/dp/4798121967/ref=cm_sw_em_r_mt_dp_JCYEEPKX12NBHWSJKA13?_encoding=UTF8&amp;psc=1</a></li><li><a href="https://qiita.com/little_hand_s/items/721afcbc555444663247" target="_blank" rel="noopener noreferrer">https://qiita.com/little_hand_s/items/721afcbc555444663247</a></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="테스트-주도-개발">테스트 주도 개발<a class="hash-link" href="#테스트-주도-개발" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="의미-4">의미:<a class="hash-link" href="#의미-4" title="Direct link to heading">​</a></h4><blockquote><p>테스트 주도 개발(test-driven development; TDD)는 프로그램 개발 방법의 하나로, 프로그램에 필요한 각 기능을 처음부터 테스트로 작성(이를 테스트 퍼스트라 함), 그 테스트가 동작해야 하는 필요최저한 구현을 한 후, 코드를 작성하는 식으로 잦은 공정을 반복하는 스타일이다.</p></blockquote><p><a href="https://ja.wikipedia.org/wiki/%E3%83%86%E3%82%B9%E3%83%88%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA" target="_blank" rel="noopener noreferrer">인용</a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="어떨-때-사용하는가-4">어떨 때 사용하는가:<a class="hash-link" href="#어떨-때-사용하는가-4" title="Direct link to heading">​</a></h4><p>프로그래밍은 자유롭게 쓸 수 있으므로, 생각하지 쓰려하면 <a href="https://www.asobou.co.jp/blog/web/props-drilling" target="_blank" rel="noopener noreferrer">React Props drilling</a> 같이 나쁜 로직으로 작성한다. 클래스, 함수를 프로그램으로 만들 때는 <strong>우선 인풋과 아웃품을 어떻게 하는가</strong> 의식하며 <strong>테스트를 먼저 적는 것</strong>은 중요하다 느낍니다.</p><ul><li>공통 퍼블릭 함수나 util를 만들 떄, 테스트하기 쉬우면서, 이해하기 쉽고, 변경하기 쉬운 함수 군을 구성하고 싶은 경우</li><li>장래적으로 부채를 만들지 않은 코드를 만들 고 싶은 경우</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="참조링크-4">참조링크:<a class="hash-link" href="#참조링크-4" title="Direct link to heading">​</a></h4><ul><li><a href="https://www.qbook.jp/column/20181009_713.html" target="_blank" rel="noopener noreferrer">https://www.qbook.jp/column/20181009_713.html</a></li><li><a href="https://shiftasia.com/ja/column/%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E9%96%8B%E7%99%BA%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8Btdd%E3%81%A8bdd/" target="_blank" rel="noopener noreferrer">https://shiftasia.com/ja/column/%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E9%96%8B%E7%99%BA%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8Btdd%E3%81%A8bdd/</a></li><li><a href="https://www.amazon.co.jp/dp/4274217884/ref=cm_sw_em_r_mt_dp_SNR9MZ09JJ0H9D964QF2" target="_blank" rel="noopener noreferrer">https://www.amazon.co.jp/dp/4274217884/ref=cm_sw_em_r_mt_dp_SNR9MZ09JJ0H9D964QF2</a></li><li><a href="https://codezine.jp/article/detail/12245" target="_blank" rel="noopener noreferrer">https://codezine.jp/article/detail/12245</a></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="행위-주도-개발">행위 주도 개발<a class="hash-link" href="#행위-주도-개발" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="의미-5">의미:<a class="hash-link" href="#의미-5" title="Direct link to heading">​</a></h4><blockquote><p>행위 주도 개발(behavior driven development; BDD)는 프로그램 개발 방법의 하나로, 테스트 주도 개발에서 파생한 것이다. 테스트 주도 개발에 작성된 테스트 케이스는 작성된 프로그램 동작이 제대로인가 어떤가 검증하기 위한 &quot;테스트&quot;이다. 테스트라는 점은 동일하지만 여기에 이제부터 작성하기 위한 프로그램이 작동할 &quot;동작&quot;이나 &quot;제약조건&quot; 즉, &quot;요구사양&quot;에 가까운 형태로 자연언어를 병기하며 테스트 코드를 작성한다.</p></blockquote><p><a href="https://ja.wikipedia.org/wiki/%E3%83%93%E3%83%98%E3%82%A4%E3%83%93%E3%82%A2%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA" target="_blank" rel="noopener noreferrer">인용</a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="어떨-때-사용하는가-5">어떨 때 사용하는가:<a class="hash-link" href="#어떨-때-사용하는가-5" title="Direct link to heading">​</a></h4><p><strong>이 코드는 명백히 이런 것을 한다</strong> 간결히 설명할 수 있는 상태의 구현인 면에서, 건전한 코드를 적을 수 있게 되었다 멋대로 생각중입니다. <strong>simple is best!</strong></p><ul><li>비엔지니어, 관계자에게 어떠한 테스트 케이스로 테스트 구현을 하는가를 설명하고 싶을 때(설명과 테스트 구현이 1:1이다)</li><li>유저가 받아들이는 표준(기능을 구현하면 구현 완료라 보는 표준)을 설정해서 받아 들여지는 표준과 테스트 구현에 대응하고 싶을 때</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="참조링크-5">참조링크:<a class="hash-link" href="#참조링크-5" title="Direct link to heading">​</a></h4><ul><li><a href="https://rihoublog.com/2018/11/06/%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AA%E3%83%BC%E3%81%AE%E5%8F%97%E5%85%A5%E5%9F%BA%E6%BA%965%E3%81%A4%E3%81%AE%E3%83%9D/" target="_blank" rel="noopener noreferrer">https://rihoublog.com/2018/11/06/%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AA%E3%83%BC%E3%81%AE%E5%8F%97%E5%85%A5%E5%9F%BA%E6%BA%965%E3%81%A4%E3%81%AE%E3%83%9D/</a></li><li><a href="https://rihoublog.com/2018/11/06/%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AA%E3%83%BC%E3%81%AE%E5%8F%97%E5%85%A5%E5%9F%BA%E6%BA%965%E3%81%A4%E3%81%AE%E3%83%9D/" target="_blank" rel="noopener noreferrer">https://rihoublog.com/2018/11/06/%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AA%E3%83%BC%E3%81%AE%E5%8F%97%E5%85%A5%E5%9F%BA%E6%BA%965%E3%81%A4%E3%81%AE%E3%83%9D/</a></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="컴포넌트-주도-개발">컴포넌트 주도 개발<a class="hash-link" href="#컴포넌트-주도-개발" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="의미-6">의미:<a class="hash-link" href="#의미-6" title="Direct link to heading">​</a></h4><blockquote><p>컴포넌트 주도 개발(CDD)는 UI와 조합할 때 먼저 컴포넌트부터 만들어 마지막에 페이지를 작성하는 &quot;bottom up&quot; 개발 프로세스.</p></blockquote><p><a href="https://wb-hp.com/blog/2020/10/12/cdd.html" target="_blank" rel="noopener noreferrer">인용</a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="어떨-때-사용하는가-6">어떨 때 사용하는가:<a class="hash-link" href="#어떨-때-사용하는가-6" title="Direct link to heading">​</a></h4><p>프론트는 잘 모르지만, React에 의해 <strong>부품(컴포넌트)을 구성해 유저 인터페이스를 만드는</strong>개념이 퍼졌으므로, 도구의 재이용이 가능해서 낭비가 적어지는 것이 좋다 생각입니다.</p><ul><li>UI에서 같은 컴포넌트 아종이 대량 발생해 이건 아차 싶어, 컴포넌트를 통일화하고 싶은 경우</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="참조링크-6">참조링크:<a class="hash-link" href="#참조링크-6" title="Direct link to heading">​</a></h4><ul><li><a href="https://www.componentdriven.org/" target="_blank" rel="noopener noreferrer">https://www.componentdriven.org/</a></li><li><a href="https://ko.reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener noreferrer">https://ko.reactjs.org/docs/components-and-props.html</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="정리">정리<a class="hash-link" href="#정리" title="Direct link to heading">​</a></h2><p>세상에는 수 많은 ㅇㅇ 주도 개발이 있네요.
이제부터 더 늘어날지도 모릅니다만, 주도 개발을 조합해서 최강의 ㅇㅇ 주도 개발을 발견하면 좋겠다 생각합니다.</p><p>실은 <strong>내가 생각한 최강의 ㅇㅇ 주도 개발</strong>도 이 글에 넣고 싶지만, 글자가 쓸 데없이 많아지므로, 속편에 등장시킬까 합니다. 기대해주세요~</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/architecture">architecture</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/번역">번역</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about ㅇㅇ 주도 설계 개발이 너무 많다." href="/La-viva-es-Sueno/blog/2022-05-13-a-lot-of-OOOO-domain"><b>Read More</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/La-viva-es-Sueno/blog/2022-05-06-atomic-design-wo-wakkata-tsumori-ni-naru">Atomic Design 아는 척하기</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2022-05-06T00:00:00.000Z" itemprop="datePublished">May 6, 2022</time> · <!-- -->11 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_sTYa"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/rewrite0w0" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">rewrite0w0</span></a></div><small class="avatar__subtitle" itemprop="description">JavaScript 개발자</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><blockquote><p><a href="https://design.dena.com/design/atomic-design-%E3%82%92%E5%88%86%E3%81%8B%E3%81%A3%E3%81%9F%E3%81%A4%E3%82%82%E3%82%8A%E3%81%AB%E3%81%AA%E3%82%8B" target="_blank" rel="noopener noreferrer">글</a></p></blockquote><p>Atomic Design이라는 말을 종종 듣습니다.</p><p>실제로 약간의 체험을 하면서 Atomic Design에 대해 생각했습니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="atomic-design">Atomic Design?<a class="hash-link" href="#atomic-design" title="Direct link to heading">​</a></h2><p>파츠/컴포넌트 단위로 정의하는 UI 디자인 수법입니다.</p><p>눈여겨봐야 할 것은 프론트 엔지니어 대부분이 만병통치약이라 여기는 여론이 높아진다는 것입니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="파츠-최소단위로-디자인한다">파츠 최소단위로 디자인한다<a class="hash-link" href="#파츠-최소단위로-디자인한다" title="Direct link to heading">​</a></h2><p>최소 단위 &quot;원자&quot;(Lv1)부터 디자인하며 &quot;분자&quot;(Lv2), &quot;생체&quot;(Lv3), &quot;템플릿&quot;(Lv4), &quot;페이지&quot;(Lv5) 순으로 디자인 작업을 합의, 진행하는 것입니다.</p><p><img loading="lazy" src="https://design.dena.com/_next/static/images/figures-1200-36427287dbc1e4481d9a2bd2a15d9159.png" alt="atomic revolution" class="img_ev3q"></p><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>Atomic Design은 &quot;원자&quot;, &quot;분자&quot; 같이 화학용어로 정의되어 있어 이해가 약간 이상하다 느끼므로 글에서는 (Lv1) 같이 레벨 표현을 덧붙였습니다.</p></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="엔지니어-작업-밑준비가-가능">엔지니어 작업 밑준비가 가능<a class="hash-link" href="#엔지니어-작업-밑준비가-가능" title="Direct link to heading">​</a></h2><p>템플릿(Lv4) 혹은 생체(Lv3) 단계에 들어가면 원자/분자(Lv 1,2) 스타일(파츠의 최소단위)가 팀에 공유, 합의되었다는 소리이므로 엔지니어가 자유롭게 쌓아 올리며 빠르게 UI 개발, 검증이 행해진다는 기대할 수 있습니다.</p><p>먼저 Twitter Bootstrap를 만들어, 그것으로 디자인한다. 이런 느낌에 가까워 &quot;디자인 밑그림(Design Comprehensive Layout)으로 스타일 가이드를 한다&quot; 순서를 역으로 한다 볼 수 있습니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="atomic-design으로-만들어보기">Atomic Design으로 만들어보기<a class="hash-link" href="#atomic-design으로-만들어보기" title="Direct link to heading">​</a></h2><p>부끄럽지만 한 번 만들어본 결과물과 함께 프로세스를 공개하겠습니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="원자lv1">원자(Lv1)<a class="hash-link" href="#원자lv1" title="Direct link to heading">​</a></h2><p>배색, 폰트 같은 정의, 라벨 버튼에 폼 파츠 단위 등 UI 최소요소를 스타일라이즈</p><p><img loading="lazy" src="https://design.dena.com/_next/static/images/1-atoms-1200-bc7b0da8305c2db3a92cf3465e6966ca.png" alt="Lv1 stylize" class="img_ev3q"></p><p>사용 빈도가 낮은 원자도 먼저 만들어두겠습니다. 허나 제작에 낭비가 많아질지도 모릅니다.(h6, hr, pre 같이)</p><p>각 원자는 Sketch였다면 Symbol화 하기 등, 디자인 컴포넌트 오브젝트로 만듭니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="분자lv2">분자(Lv2)<a class="hash-link" href="#분자lv2" title="Direct link to heading">​</a></h2><p>원자(Lv1)를 붙입니다. 즐겁습니다.</p><p><img loading="lazy" src="https://design.dena.com/_next/static/images/2-molecules-1200-349b9aaed810cabcb56dba2aafd39479.png" alt="Lv2" class="img_ev3q"></p><p>좀 애매한데 싶어서 원자를 다시 고치는 경우가 종종 있지만, 이건 적응의 문제일지도 모릅니다.</p><p>분자도 완성되면 Sketch였다면 Symbol화합니다. 근래 Sketch는 Symbol를 네스트할 수 있어 편합니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="생체lv3">생체(Lv3)<a class="hash-link" href="#생체lv3" title="Direct link to heading">​</a></h2><p>분자(Lv2)를 붙입니다. 부족한 원자가 있는데? 같은 것을 느끼기도 합니다.</p><p><img loading="lazy" src="https://design.dena.com/_next/static/images/3-organisms-1200-3260a7ae52293d9eb86e0e62010d77ec.png" alt="Lv3" class="img_ev3q"></p><p>또 애매한데 싶은 원자, 분자를 고치는 경우가 종종 있습니다. 생체도 완성했으면 Sketch라면 Symbol화합니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="템플릿lv4">템플릿(Lv4)<a class="hash-link" href="#템플릿lv4" title="Direct link to heading">​</a></h2><p>생체(Lv3)를 붙입니다. 와이어 프레임 같은 느낌일지도 모릅니다.</p><p>여기까지 드디어 도착했는데, 고쳐쓰는 수고를 더는 의미로 손으로 와이어 프레임을 먼저 그리는 것이 좋을 것 같다 생각했습니다.</p><p><img loading="lazy" src="https://design.dena.com/_next/static/images/4-templates-1-1200-7f0a8b158957cc559c2d1c3637b9e879.png" alt="Lv4" class="img_ev3q"></p><p>또 애매한데 싶은 생체, 분자, 원자를 다시 고쳐쓰는 경우가 종종 있습니다. 이것에는 적응했습니다 적응. 유저 테스트할 때 색이 좀~ 이런 이야기로 다시 고쳐쓰지 않으면 좋겠습니다만...</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="페이지lv5">페이지(Lv5)<a class="hash-link" href="#페이지lv5" title="Direct link to heading">​</a></h2><p>템플릿(Lv4)를 브래쉬업, 내용을 넣습니다.</p><p><img loading="lazy" src="https://design.dena.com/_next/static/images/5-pages-2-1200-3b62a3c9d52521e18a3fff1de38b12ea.png" alt="Lv5" class="img_ev3q"></p><p>조금 저조차도 거시기한 디자인이 되버렸습니다...화면 전체의 색감 같은 것도 여기서 보이기에 역시 적응이 필요하다 느낍니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="atomic-design-감상">Atomic Design 감상<a class="hash-link" href="#atomic-design-감상" title="Direct link to heading">​</a></h2><ol><li><p>아직 제가 적응하지 못한 부분도 있어서, 조금 어렵다는 인상입니다. CSS Framework... 특히 Twitter Bootstrap를 기반으로 한 디자인한다는 느낌으로 만들면 접근하기 쉬울지도 모릅니다.</p></li><li><p>웹디자인으로는 좀 심심한 느낌일지도 모릅니다(제 스킬 문제일 수도 있습니다). 일단 모든 웹디자인에 적용하기보단, 서비스 UI 디자인에 특화하는 접근방법도 좋을 것 같습니다.</p></li><li><p>기반 디자인이 있어 아트디렉션에 올리는 UI를 만들 때 효율적일 듯합니다. 또, 풀 스크래치를 한다기 보다는 프로젝트를 변환하면서 빚어내느 것이 좋을 듯 합니다. LEAN 개발에 의해 MVP 개발 페이즈라면 iOS, Android 디자인 가이드라인을 기초원리=원자/분자 단위로 생체, 템플릿을 정의해 나간다는 접근 흐름이 이해하기 쉬울듯 합니다.</p></li><li><p>Atomic Design 수법과 보통 디자인 수법을 믹스인하면, 풀스크래치라도 괜찮게 나올지도 모릅니다. 예를 들어 일단 보통하는 방법으로 디자인해서 화면 전체를 만든 후에, 파츠를 분할, 공통화하며 Atomic Design의 프레임워크와 비교, 스타일가이드를 원자에서 정의하는 순서를 밟으면 빠지는 부분을 확인할 수 있으며, 구현 팀과 합의도 쉬워질 것 같습니다.</p></li><li><p>이 방법으로 개발한 애플리케이션 제작기 글을 종종 보지만 대부분이 페이지의 디자인 밑그림(Design Comprehensive Layout)을 원자, 분자 단계에서 &quot;상상해&quot; 개발하는 느낌입니다. 이는 꽤나 어려워보이지만, 적응되면 상당히 효율적일 것 같습니다.</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="특히-괜찮다-느낀점">특히 괜찮다 느낀점<a class="hash-link" href="#특히-괜찮다-느낀점" title="Direct link to heading">​</a></h2><p>서비스 개발 시에 운용 페이즈 따라, 현실적인 디자이너가 반드시 모든 성과물을 제로 베이스에서 작성하지 못할 수도 있으므로 플래너나 엔지니어가 프로토타입 레벨에서 만들 수 있는 구조 복음이 될지도 모릅니다. 의존도를 낮추면서 디자이너 팀 안에서 솔로플레이 방지도 가능할 것 같습니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="걱정-실제로-운용될-때를-생각하자">걱정, 실제로 운용될 때를 생각하자<a class="hash-link" href="#걱정-실제로-운용될-때를-생각하자" title="Direct link to heading">​</a></h2><ol><li><p>단조로운 작업이 계속되는 디자인 작업에 질려버릴지도 모릅니다. 베이스는 평범한 방법으로 해도될 듯합니다.</p></li><li><p>서비스가 운용될 때, 원자와 같은 원자(button2 같이)를 만드는 악몽이 보입니다... 다만 통상적인 방법보다 발생 확률을 억누를 수 있을 것 같습니다.</p></li><li><p>엔지니어가 원자 분자 단계로 쌓아올린 디자인은 레이아웃 단계가 아니므로, 프로덕션 단계에서는 결국 디자이너가 손을 대야하는 등, 재작업해야할 여지가 있을지도 모릅니다. 손을 써야하는 부분의 우선 순위를 붙이는 것이 좋을지도 모릅니다.</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="atomic-design-참고자료">Atomic Design 참고자료<a class="hash-link" href="#atomic-design-참고자료" title="Direct link to heading">​</a></h2><p><a href="http://patternlab.io/" target="_blank" rel="noopener noreferrer">pattern lab</a></p><p>Atomic Design를 추진하는 공식에 가까운 사이트 &amp; 시스템을 제작하는 도구입니다. 실제로 도입할 때 여기 도구를 지침으로 쓰는 것이 좋아보입니다.</p><p><a href="http://apbcss.com/" target="_blank" rel="noopener noreferrer">APBCSS</a></p><p>Atomic Design 표준으로 제작된 CSS Framework입니다. CSS 클래스 정의가 특징적이네요.</p><p>개발자 시선 이외라면 반드시 이거여야 하는 이유는 잘 모르겠지만, Atomic Design의 이해가 깊어질 것 같습니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="정리">정리<a class="hash-link" href="#정리" title="Direct link to heading">​</a></h2><ol><li><p>서비스 디자인은 지속적으로 짧은 사이클로 수정하지 않으면 안되므로, Web/UI 디자인이 아니라면 독자적으로 해결해야하는 문제를 대하는 하나의 방법</p></li><li><p>Web/UI 디자인에는 에디토리얼, 그래픽에서 나온 방법이 많이 있지만 Atomic Design은 마크업, 코딩 시선으로 낳은 방법</p></li><li><p>디자인의 최종적 목표는 가치를 부여한다, 문제를 해결하는 것이라면 다양한 방법이 있다면 좋은 것</p></li></ol><p>Atomic Design의 시점으로 서비스 디자인 프로세스 개선에 도전하는 것도 좋은 일일지도 모릅니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/design">design</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/architecture">architecture</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/번역">번역</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about Atomic Design 아는 척하기" href="/La-viva-es-Sueno/blog/2022-05-06-atomic-design-wo-wakkata-tsumori-ni-naru"><b>Read More</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/La-viva-es-Sueno/blog/2022-05-01-flux-and-react">flux와 가상 DOM에 대해서</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2022-05-01T00:00:00.000Z" itemprop="datePublished">May 1, 2022</time> · <!-- -->15 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_sTYa"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/rewrite0w0" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">rewrite0w0</span></a></div><small class="avatar__subtitle" itemprop="description">JavaScript 개발자</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>React 다루다보면 <strong>Flux</strong>를 만난다. 그래서 이에 대해 조사해보기로 했다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="가상-dom">가상 DOM<a class="hash-link" href="#가상-dom" title="Direct link to heading">​</a></h2><p>먼저 Flux를 만나기 전에, React하면 떠오르는 친구인 가상 DOM을 보자.</p><p><a href="https://ko.reactjs.org/docs/faq-internals.html#gatsby-focus-wrapper" target="_blank" rel="noopener noreferrer">공식문서에 의하면</a></p><blockquote><p>Virtual DOM (VDOM)은 UI의 이상적인 또는 <strong>“가상”</strong>적인 표현을 <strong>메모리에 저장</strong>하고 ReactDOM과 같은 라이브러리에 의해 <strong>“실제” DOM과 동기화</strong>하는 프로그래밍 개념입니다. 이 과정을 <strong>재조정</strong>이라고 합니다.</p><p>이 접근방식이 React의 <strong>선언적 API를 가능하게</strong> 합니다. <strong>React에게 원하는 UI의 상태를 알려주면 DOM이 그 상태와 일치하도록 합니다.</strong> 이러한 방식은 앱 구축에 사용해야 하는 어트리뷰트 조작, 이벤트 처리, 수동 DOM 업데이트를 <strong>추상화</strong>합니다.</p><p>“virtual DOM”은 특정 기술이라기보다는 <strong>패턴에 가깝기 때문에 사람들마다 의미하는 바가 다릅니다.</strong> React의 세계에서 “virtual DOM”이라는 용어는 보통 <strong>사용자 인터페이스를 나타내는 객체</strong>이기 때문에 <strong>React elements와 연관</strong>됩니다. 그러나 React는 컴포넌트 트리에 대한 추가 정보를 포함하기 위해 “fibers”라는 내부 객체를 사용합니다. 또한 React에서 “virtual DOM” 구현의 일부로 간주할 수 있습니다.</p></blockquote><p><strong>한 마디로, DOM과 별개로 가상의 표현을 두고, 그것을 추상적으로 조작하며 재조정하는 것이다.</strong></p><blockquote><p>추가: DOM은 그래프이론에서 온 것으로 애플리케이션이 복잡해지고 조작이 많아지면 <strong>페이지 렌더링 시에 계산량이 폭발해서 성능 저하</strong>가 일어난다. 그래서 <strong>변경 전, 변경 후를 가지고 차이만 갱신하면 적은 계산량으로 렌더링할 수 가능하다는 아이디어에서 출발</strong>한 것으로 <strong>UI의 가상적인 표현을 메모리에 저장하고, React를 통해 실제 DOM과 동기화하는 개념</strong></p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dom">DOM<a class="hash-link" href="#dom" title="Direct link to heading">​</a></h3><p>그럼 애초에 DOM은 무엇일까?</p><p><a href="https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener noreferrer">MDN를 보자</a></p><blockquote><p>문서 객체 모델(The Document Object Model, 이하 DOM) 은 <strong>HTML, XML 문서의 프로그래밍 interface</strong> 이다. <strong>DOM은 문서의 구조화된 표현</strong>(structured representation)을 제공하며 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공하여 그들이 문서 구조, 스타일, 내용 등을 <strong>변경</strong>할 수 있게 돕는다. <strong>DOM 은 nodes와 objects로 문서를 표현한다.</strong> 이들은 웹 페이지를 스크립트 또는 프로그래밍 언어들에서 사용될 수 있게 연결시켜주는 역할을 담당한다.</p><p>웹 페이지는 일종의 문서(document)다. 이 문서는 웹 브라우저를 통해 그 내용이 해석되어 웹 브라우저 화면에 나타나거나 HTML 소스 자체로 나타나기도 한다. 동일한 문서를 사용하여 이처럼 다른 형태로 나타날 수 있다는 점에 주목할 필요가 있다. <strong>DOM 은 동일한 문서를 표현하고, 저장하고, 조작하는 방법을 제공한다.</strong> DOM 은 <strong>웹 페이지의 객체 지향 표현</strong>이며, 자바스크립트와 같은 스크립팅 언어를 이용해 DOM 을 수정할 수 있다.</p></blockquote><p><strong>한 마디로, 형식있는 (웹)문서를 조작하는 표현이다.</strong></p><p>가상 흔히 쓰는 방법은 이하와 같이 무엇인가 선택하거나, 만들어서 요소를 확인/추가/변경/삭제 등등을 하는 것</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> element </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token dom variable" style="color:#36acaa">document</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">querySelector</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;무엇인가&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">element</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">children</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> div </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token dom variable" style="color:#36acaa">document</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">createElement</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;div&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">div</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">textContent</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;test&#x27;</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="flux">Flux<a class="hash-link" href="#flux" title="Direct link to heading">​</a></h2><p>데이터 흐름을 처리하는 방법이다.</p><p>또한 Facebook이 클라이언트 사이드의 Web 애플리케이션을 구축하기 위해 사용하고 있는 애플리케이션 아키텍처이다.</p><p>단방향 모델이며, <code>MVC</code>는 금방 복잡화되기 때문에 facebook(현 Meta)는 <a href="http://www.infoq.com/news/2014/05/facebook-mvc-flux" target="_blank" rel="noopener noreferrer"><code>MVC</code> 패턴을 버리고 Flux 패턴을 선택했다.</a></p><p>왜 그렇게 했는가 <a href="https://www.youtube.com/watch?list=PLb0IAmt7-GS188xDYE-u1ShQmFFGbrk0v&amp;time_continue=621&amp;v=nYkdrAPrdcw" target="_blank" rel="noopener noreferrer">영상</a>에서는 이렇게 설명한다. (물론 facebook인 MVC를 오독을 했다는 의견도 있다.)</p><blockquote><p>MVC를 작은 애플리케이션에 적용했지만 이런 식으로 복잡해졌다.</p></blockquote><p><img loading="lazy" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/news/2014/05/facebook-mvc-flux/ja/resources/flux-react-mvc.png" alt="MVC" class="img_ev3q"></p><blockquote><p>이렇게되면 모델관련 뷰가 대량으로 추가되어 복잡화가 폭발했다.</p><p>이러한 애플리케이션은 모델과 뷰 사이의 쌍방향 데이터 흐름이 만들어질 가능성이 있으므로, 이해하거나 디버그가 어려워진다. 그렇기에 Flux에 의한 설계를 대안으로 선택했다.</p></blockquote><p><img loading="lazy" src="https://camo.qiitausercontent.com/dfc8fb3817c3f59861ced5659268a27226d01218/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f3133343239342f66356133396564642d323462392d656362622d323837332d3330646265623933316533382e706e67" alt="Flux Basic" class="img_ev3q"></p><p><img loading="lazy" src="https://camo.qiitausercontent.com/c74d7bca36e1b79bcbc5885a231b3854b2902afa/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f33393338322f66643533356364332d386462362d303431312d326138652d3739316139626361356631632e706e67" alt="Flux + Action" class="img_ev3q"></p><blockquote><p>이 그림에서</p><p><code>Store</code>는 애플리케이션의 모든 데이터를 포함하고 있으며,</p><p><code>Dispatcher</code>는 <code>MVC 그림의</code>에서 <code>Controller</code>를 갈아끼우므로 어떤 Action이 일어날 때,</p><p>어떻게 <code>Store</code>를 갱신할까 결정하는 것이다.
Store가 변경될 때는 <code>View</code>도 동시에 갱신되어 그것과 함께 <code>Dispatcher</code>가 처리될 <code>Action</code>를 발생할 수 있다.
이로인해 시스템의 컴포넌트 사이에 단방향 데이터흐름만 생긴다는 보장한다.</p><p>복수의 Store, View를 갖는 시스템도, 하나의 Store, View를 갖은 시스템 모두 같다 볼 수 있다.</p><p>왜냐면 데이터는 단일한 방향으로만 흐르며, 각 Store, View가 서로 직접 영향을 미치지 않기 때문이다.</p></blockquote><p><code>Facebook이 직접 밝힌 상세한 설명을 보자.</code></p><blockquote><p>dispatcher는 Flux 애플리케이션 모든 데이터 흐름을 관리하는 중앙 허브이다.</p><p>이는 본질적으로는 Store 안에 콜백을 등록하는 곳이다.</p><p>각 Store는 각 자신을 등록한 제공을 제공한다.</p><p>이 dispatcher가 어떤 액션에 대응할 때 애플리케이션 안에 모든 Store는, 그곳에 <strong>등록되어 있는 콜백에 의해 액션으로인해 생긴 데이터를 송신</strong>하는 것이다.</p><p>애플리케이션 성장에 따라, 결정된 순서로 등록된 콜백 실행을 하므로, Store 간의 의존관계를 관리하는 dispatcher는 더욱 불가결한 것이 된다.</p><p>Store는 다른 Store 갱신이 완료할 때까지 갖을 수 있다.</p><p>그리고 그 후, 자신을 갱신한다.</p><p><strong>Store는 애플리케이션 상태와 로직을 포함한다.</strong></p><p><em>Store 역할은 고전적인 MVC에 의해 Model의 역할과 닮아있지만,</em></p><p><strong>여러 객체 상태를 관리해서, 하나의 객체 인스턴스가 아닌 것이 차이이다.</strong></p><p>또한 Backbone 프레임워크 콜랙션과 같지는 않다.</p><p>ORM 형식 객체 집합을 관리하는 것보다 단순하며,</p><p>Store는 애플리케이션 안에 특정 도메인에 대한 애플리케이션 상태관리한다.</p></blockquote><p>일반적인 사용 예제는 이러하다</p><p><img loading="lazy" src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F150569%2F41f7cd50-765f-7eb6-badf-8e0b5917bb2d.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;w=1400&amp;fit=max&amp;s=95c8d356c2bd4c7303dc2325fda8e1fb" alt="Flux React Example" class="img_ev3q"></p><blockquote><p>여담으로 <code>observer</code> 패턴이다.</p></blockquote><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p><strong>dispatcher?</strong> : 사전적 의미 <em>발송자</em></p><p>dispatcher는 스토어 사이 의존관계를 관리하는 것.</p><p>Flux에서는 View / Model의 증가 대신에 Action과 Store가 증가한다.</p><p>그러기에 모든 데이터 처리가 dispatcher에 집약된다.</p><p>등록된 콜백함수에 페이로드를 브로드캐스트하기 위함.</p><p><a href="https://github.com/facebook/flux/blob/main/src/Dispatcher.js" target="_blank" rel="noopener noreferrer">dispatcher.js</a></p><p>dispatcher는 action을 받아, dispatcher에 등록된 action를 dispatch한다.</p><p><strong>모든 store는 모든 action를 받는다.</strong></p><p>각 애플리케이션에는 싱글톤 dispatcher가 하나만 존재한다.</p><p>예시:</p><ol><li>유저가 todo를 입력하고 Enter를 입력</li><li>view는 이 이벤트를 포착해서, todo 입력을 포함하는 <code>add-todo</code> action를 dispatch한다.</li><li>모든 store가 이 action을 받는다.</li></ol><p>그래서 <strong>Action에 의한 Store 변경</strong>이라는 점이 명백하기 때문에, Action 이후 애플리케이션 상태가 예측가능해진다.</p><p><a href="https://qiita.com/knhr__/items/5fec7571dab80e2dcd92" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F134294%2F460f6ff3-fd48-989a-3f30-a52c0b8cdc99.png?ixlib=rb-4.0.0&amp;auto=format&amp;gif-q=60&amp;q=75&amp;w=1400&amp;fit=max&amp;s=141271f511a0df153babb796458bebe5" alt="flux image" class="img_ev3q"></a></p><p>Store가 증가하고, Store는 다른 스토어 갱신이 끝날 때까지 View에 전달하지 않는다. 또한 Store는 다른 Store에 계층구조적으로 의존한다.</p><p>그래서 Store는 다른 Store의 의존에 신경쓰지 않은 상태로 순수하게 데이터 갱신만 생각하면 된다.</p><p>또한 애플리케이션 전체 관점으로도 데이터를 다룰 때는 Store만 갱신하면 된다. Store 갱신은 부작용이 없도록 데이터를 갱신을 하므로, 같은 데이터인데 어느쪽은 오래되었고, 어느 쪽은 새로운 상황 같은 것이 사라진다.</p><p>새로운 View, Action 등 코드를 작성해야하지만 복잡하고 예측 불가능한 상황이 일어나기 어려워지므로 충분히 이득이 상황이다.</p></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="정리">정리<a class="hash-link" href="#정리" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="mvc">MVC<a class="hash-link" href="#mvc" title="Direct link to heading">​</a></h3><p><code>C -&gt; (M &lt;-&gt; V)</code></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="flux-1">Flux<a class="hash-link" href="#flux-1" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Views ---&gt; (actions) ----&gt; Dispatcher ---&gt; (registered callback) ---&gt; Stores -------+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Ʌ                                                                                   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|                                                                                   V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+-- (Controller-Views &quot;change&quot; event handlers) ---- (Stores emit &quot;change&quot; events) --+</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>그러나 Flux와 MVC는 완전히 다른 개념이 아니라, 지금까지 개념의 연장선이다.</p><p>단지 복잡화되기 쉬운 부분을 명확히 했을 분이다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="react와-flux와-가상-dom">React와 Flux와 가상 DOM<a class="hash-link" href="#react와-flux와-가상-dom" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="react는-왜-가상-dom일까">React는 왜 가상 DOM일까?<a class="hash-link" href="#react는-왜-가상-dom일까" title="Direct link to heading">​</a></h3><p><strong>어느정도의 설계와 속도 양립</strong>이 가능하기 때문.</p><p>이를 위한 방법으로 <code>완성된 가상 DOM에 계속 Push한다</code></p><p><a href="https://qiita.com/mizchi/items/4d25bc26def1719d52e6#virtual-dom%E3%81%8C%E3%82%82%E3%81%9F%E3%82%89%E3%81%99%E5%8F%A4%E3%81%8F%E3%81%A6%E6%96%B0%E3%81%97%E3%81%84%E8%80%83%E3%81%88%E6%96%B9" target="_blank" rel="noopener noreferrer">이 방법은 <code>HTTP 리퀘스트 =&gt; HTML 반환</code> 조작과 같다(!)</a></p><p>이를 위한 수단으로 선택한 것이 Flux이다.</p><p>결국 Flux와 가상 DOM의 조합으로 인해서</p><p>가상 DOM에 의해 <strong>퍼포먼스면에서 문제없이 늘 제로에서 상태를 구축</strong>이 가능하다.</p><p>대신, 데이터 바인드와 퍼포먼스, 이벤트 핸들러의 사정으로 이전의 HTML를 버리는 것은 불가능했다.</p><p>제로에서 구축해 HTML를 push하면, 화면이 한 번 사라지는데다가,</p><p>이벤트 핸들러 처리를 반드시 한 번 처리해야 한다.</p><p>하지만 가상 DOM에서는 이벤트 핸들러도, 동시에 적용되고 patch할 대상이므로 신경쓸 일은 아니다.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="번외-redux">번외: Redux<a class="hash-link" href="#번외-redux" title="Direct link to heading">​</a></h3><p>Redux는 Flux의 파생이다.</p><p>하지만 차이가 있다.</p><p>Redux에는 3원칙이 있으며, <a href="https://redux.js.org/understanding/history-and-design/prior-art#flux=" target="_blank" rel="noopener noreferrer"><code>Dispatcher</code>는 없다.</a></p><blockquote><p><a href="https://redux.js.org/understanding/thinking-in-redux/three-principles" target="_blank" rel="noopener noreferrer">3원칙:</a></p><ul><li>Single source of truth: 신뢰할 유일한 정보처</li><li>State in read-only: State는 읽기 전용</li><li>Changes are made with pure functions: action이 state를 변경할 때 reducer를 실행, reducer는 action는 state를 받으며, 새로운 state를 반환하는 순수한 함수이다.</li></ul></blockquote><p>또 State 객체를 직접 변환하지 않고 새로운 state 객체로 갈아끼우는 방법을 취한다.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="flux-2">Flux<a class="hash-link" href="#flux-2" title="Direct link to heading">​</a></h4><p><img loading="lazy" src="https://camo.qiitausercontent.com/458d7d52d34c4e3ae7b390af76985292ae1b1b02/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f33393338322f32363464633637652d646136352d343766332d643735312d3836626137356135353233372e6a706567" alt="Flux" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="redux">Redux<a class="hash-link" href="#redux" title="Direct link to heading">​</a></h4><p><img loading="lazy" src="https://camo.qiitausercontent.com/50fac8c3a36d87cefc34e41382dd9feebf5e7fe4/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f33393338322f38356530393432392d643966362d303738392d386434332d6364613637643166323037652e6a706567" alt="Redux" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="읽을거리">읽을거리<a class="hash-link" href="#읽을거리" title="Direct link to heading">​</a></h2><ul><li><a href="https://facebook.github.io/flux/" target="_blank" rel="noopener noreferrer">https://facebook.github.io/flux/</a></li><li><a href="https://reactjs.org/blog/2014/05/06/flux.html" target="_blank" rel="noopener noreferrer">https://reactjs.org/blog/2014/05/06/flux.html</a></li><li><a href="https://qiita.com/mizchi/items/4d25bc26def1719d52e6" target="_blank" rel="noopener noreferrer">https://qiita.com/mizchi/items/4d25bc26def1719d52e6</a></li><li><a href="https://zenn.dev/hanak1a/articles/10206c2a4201521b2abc" target="_blank" rel="noopener noreferrer">https://zenn.dev/hanak1a/articles/10206c2a4201521b2abc</a></li><li><a href="https://www.infoq.com/news/2014/05/facebook-mvc-flux/" target="_blank" rel="noopener noreferrer">https://www.infoq.com/news/2014/05/facebook-mvc-flux/</a></li><li><a href="https://velopert.com/3236" target="_blank" rel="noopener noreferrer">https://velopert.com/3236</a></li><li><a href="https://ko.reactjs.org/" target="_blank" rel="noopener noreferrer">https://ko.reactjs.org/</a></li><li><a href="https://developer.mozilla.org/" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/</a></li><li><a href="https://qiita.com/kouh/items/dfc14d25ccb4e50afe89" target="_blank" rel="noopener noreferrer">https://qiita.com/kouh/items/dfc14d25ccb4e50afe89</a></li><li><a href="https://saneyukis.hatenablog.com/entry/2014/09/26/174750" target="_blank" rel="noopener noreferrer">https://saneyukis.hatenablog.com/entry/2014/09/26/174750</a></li><li><a href="https://qiita.com/Ted-HM/items/7dde25dcffae4cdc7923" target="_blank" rel="noopener noreferrer">https://qiita.com/Ted-HM/items/7dde25dcffae4cdc7923</a></li><li><a href="https://kotobank.jp/word/%E3%83%87%E3%82%A3%E3%82%B9%E3%83%91%E3%83%83%E3%83%81-6089" target="_blank" rel="noopener noreferrer">https://kotobank.jp/word/%E3%83%87%E3%82%A3%E3%82%B9%E3%83%91%E3%83%83%E3%83%81-6089</a></li><li><a href="https://e-words.jp/w/%E3%83%87%E3%82%A3%E3%82%B9%E3%83%91%E3%83%83%E3%83%81%E3%83%A3.html" target="_blank" rel="noopener noreferrer">https://e-words.jp/w/%E3%83%87%E3%82%A3%E3%82%B9%E3%83%91%E3%83%83%E3%83%81%E3%83%A3.html</a></li><li><a href="https://qiita.com/knhr__/items/5fec7571dab80e2dcd92" target="_blank" rel="noopener noreferrer">https://qiita.com/knhr__/items/5fec7571dab80e2dcd92</a></li><li><a href="https://hogehuga.com/post-1095/" target="_blank" rel="noopener noreferrer">https://hogehuga.com/post-1095/</a></li><li><a href="https://www.freecodecamp.org/news/an-introduction-to-the-flux-architectural-pattern-674ea74775c9/" target="_blank" rel="noopener noreferrer">https://www.freecodecamp.org/news/an-introduction-to-the-flux-architectural-pattern-674ea74775c9/</a></li><li><a href="https://zenn.dev/arranzt/articles/01807d1b3d2fc1" target="_blank" rel="noopener noreferrer">https://zenn.dev/arranzt/articles/01807d1b3d2fc1</a></li><li><a href="https://programmingwithmosh.com/react/react-virtual-dom-explained/" target="_blank" rel="noopener noreferrer">https://programmingwithmosh.com/react/react-virtual-dom-explained/</a></li><li><a href="https://qiita.com/syossan27/items/7e1b2e07ac68b96bdaa7" target="_blank" rel="noopener noreferrer">https://qiita.com/syossan27/items/7e1b2e07ac68b96bdaa7</a></li><li><a href="https://blog.logrocket.com/jotai-vs-recoil-what-are-the-differences/" target="_blank" rel="noopener noreferrer">https://blog.logrocket.com/jotai-vs-recoil-what-are-the-differences/</a></li><li><a href="https://stackoverflow.com/questions/32461229/why-use-redux-over-facebook-flux" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/32461229/why-use-redux-over-facebook-flux</a></li><li><a href="https://reactjs.org/blog/2014/07/30/flux-actions-and-the-dispatcher.html" target="_blank" rel="noopener noreferrer">https://reactjs.org/blog/2014/07/30/flux-actions-and-the-dispatcher.html</a></li><li><a href="https://github.com/facebook/flux/tree/db8e97d6ee972f7012edbfd34f2dc6f6e3b85843/examples/flux-concepts" target="_blank" rel="noopener noreferrer">https://github.com/facebook/flux/tree/db8e97d6ee972f7012edbfd34f2dc6f6e3b85843/examples/flux-concepts</a></li></ul></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/architecture">architecture</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/react">react</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/감상">감상</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about flux와 가상 DOM에 대해서" href="/La-viva-es-Sueno/blog/2022-05-01-flux-and-react"><b>Read More</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/La-viva-es-Sueno/blog/difference-architecture-and-design">아키텍처와 디자인</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2022-04-14T00:00:00.000Z" itemprop="datePublished">April 14, 2022</time> · <!-- -->7 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_sTYa"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/rewrite0w0" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">rewrite0w0</span></a></div><small class="avatar__subtitle" itemprop="description">JavaScript 개발자</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p><a href="https://aws.amazon.com/it/solutions/case-studies/sky-case-study/?nc1=h_ls" target="_blank" rel="noopener noreferrer">글</a>을 읽다가 문득 <strong>아키텍처와 디자인(설계)라는 말을 종종 듣는데 도대체 차이가 무엇일까?</strong> 궁금했다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="아키텍처">아키텍처<a class="hash-link" href="#아키텍처" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="https://d1.awsstatic.com/industry-images-customer-references/SkyItalia_SystemEngineeringView.c98ea3314d41aad1a13a5c9bea2516f2fdd0f142.png" alt="architecture" class="img_ev3q"></p><blockquote><p><a href="https://aws.amazon.com/it/solutions/case-studies/sky-case-study/?nc1=h_ls" target="_blank" rel="noopener noreferrer">출처</a></p></blockquote><blockquote><p>아키텍처</p><p>『정보·통신』 기능 면에서 본 컴퓨터의 구성 방식. 기억 장치의 주소 방식, 입출력 장치의 채널 구조 따위를 가리킨다.</p><p>출처: <a href="https://stdict.korean.go.kr" target="_blank" rel="noopener noreferrer">국립국어원 표준국어대사전</a></p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="디자인">디자인<a class="hash-link" href="#디자인" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="https://user-images.githubusercontent.com/6892666/65833569-bb34fc00-e29f-11e9-8516-79cbd9f8f07b.png" alt="design" class="img_ev3q"></p><blockquote><p><a href="https://khalilstemmler.com/articles/software-design-architecture/full-stack-software-design/" target="_blank" rel="noopener noreferrer">출처</a></p></blockquote><blockquote><p>디자인</p><p>의상, 공업 제품, 건축 따위 실용적인 목적을 가진 조형 작품의 설계나 도안.</p><p>출처: <a href="https://stdict.korean.go.kr" target="_blank" rel="noopener noreferrer">국립국어원 표준국어대사전</a></p></blockquote><p>조사해보니, 디자인은 아마 가장 오해하기 쉬운 말인 것 같다.
흔히 UI/UX 구성할 때도 디자인 구성한다하며, 옷을 고를 때도 디자인이 좋다하는 등 용도가 넓기 때문이다.</p><p>개발에서 디자인은 <a href="https://www.patterns.dev/" target="_blank" rel="noopener noreferrer">디자인 패턴</a>혹은 <a href="https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4" target="_blank" rel="noopener noreferrer">소프트웨어 디자인 패턴</a>이 의미 전달이 잘 되는 것 같다.</p><p>흥미로운건 <a href="https://en.wikipedia.org/wiki/Architectural_pattern" target="_blank" rel="noopener noreferrer">아키텍처 패턴</a>이 <a href="https://en.wikipedia.org/wiki/Software_design_pattern" target="_blank" rel="noopener noreferrer">소프트웨어 디자인 패턴</a>에 포함되어 있다는 것이다.</p><blockquote><p>그럼 아키텍처는 디자인 안에 포함되어 있는 것인가?</p></blockquote><p><a href="https://ko.wikipedia.org/wiki/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98_%ED%8C%A8%ED%84%B4" target="_blank" rel="noopener noreferrer">위키</a>에서는 이런 언급을 한다.</p><blockquote><p>아키텍처 패턴은 소프트웨어 디자인 패턴과 비슷하지만 더 넓은 범위에 속한다.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="아키텍처와-디자인">아키텍처와 디자인<a class="hash-link" href="#아키텍처와-디자인" title="Direct link to heading">​</a></h2><ul><li>패턴<ul><li>프로그램 안에서 공통점을 추출하는 것</li><li>프로그래밍 패러다임<ul><li>언어 특유의 것</li></ul></li><li>디자인 패턴<ul><li>소프트웨어 구축에 의해 반복 발생 문제를 해결</li><li>코드에서 공통점에 관련한 것</li><li>더 작은 서브시스템 구축하기 위한 스킴 제공</li><li>언어에 영향을 받는다</li><li>실체와 관계 구조, 동작의 일부를 구체화하는 중간 전략</li></ul></li><li>architectural 패턴<ul><li>소프트웨어 시스템의 기본적 구조 구성</li><li>디자인 패턴보다 상위 수준의 공통성</li><li>대규모 요소, 전역적 특성 및 메커니즘 큰 그림 전략</li></ul></li></ul></li></ul><blockquote><p><a href="https://stackoverflow.com/questions/4243187/whats-the-difference-between-design-patterns-and-architectural-patterns" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/4243187/whats-the-difference-between-design-patterns-and-architectural-patterns</a></p></blockquote><hr><p>둘 다 아이디어에 관한 설명이다만, 아키텍처는 <code>추상적 관점</code> 디자인은 <code>아이디어의 구현 관점</code> 초점을 맞춘다. 디자인은 아키텍처보다 자세하다. 아키텍처는 전체 시스템의 추상적 그림을 그리며, 디자인은 특정 일부의 관련 영역 구현을 그린다.</p><blockquote><p><a href="https://www.linkedin.com/pulse/architectural-vs-design-patterns-software-engineering-asher-toqeer" target="_blank" rel="noopener noreferrer">https://www.linkedin.com/pulse/architectural-vs-design-patterns-software-engineering-asher-toqeer</a></p></blockquote><hr><p><code>아키텍처</code>는 저수준의 세부사항과는 <em>분리된</em> <strong>고수준</strong>의 무언가를 가리킬 때 사용하며, <code>디자인</code>은 <strong>저수준</strong>의 구조 또는 결정사항등을 의미 할 때가 많다. 그러나 아키텍트가 실제로 하는 일을 보면 이런 구분은 무의미하다</p><p>새로운 집을 설계하는 아키텍트가 있다 치자.
이 때 아키텍처를 가지고 있는가? 그렇다.
그럼 아키텍처는 무엇인가? 아마 <code>집의 형태, 외관, 입면도, 공간, 방의 배치 등</code>이 여기에 포함된다. 하지만 이게 아키텍트가 만든 도면을 살펴보면 무수히 많은 저수준의 세부사항도 확인할 수 있다. <code>콘센트, 전등 스위치, 전등</code>이 모두 어디에 위치하는지를 도면에서 알 수 있다. 보일러는 어디에 놓이고, 온수기, 배출 펌프의 크기와 위치는 어떻게 되는지 역시 볼 수 있다. 벽, 지붕 그리고 기초 공사가 어떻게 진행될지도 상세히 확인할 수 있다.</p><p>다시 말해, 모든 고수준의 결정사항을 지탱하는 모든 세부사항을 자세하게 확인할 수 있다. 이러한 저수준의 세부사항과 고수준의 결정사항은 집의 전체 설계의 구성요소가 된다.</p><p>소프트웨어 설계도 마찬가지다. <code>저수준의 세부사항과 고수준의 구조는 모두 소프트웨어 전체 설계의 구성요소다</code>. 이 둘은 단절 없이 이어진 직물과 같으며, 이를 통해 대상 시스템의 구조를 정의한다. <strong>개별로는 존재할 수 없고, 실제 이 둘을 구분 짓는 경계는 뚜렷하지 않다</strong>. 고수준에서 저수준으로 향하는 의사결정의 연속성만 있을 뿐이다.</p><blockquote><p><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=202322454" target="_blank" rel="noopener noreferrer">클린 아키텍처</a></p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="결론">결론<a class="hash-link" href="#결론" title="Direct link to heading">​</a></h2><p><strong><a href="http://encykorea.aks.ac.kr/Contents/Item/E0036708" target="_blank" rel="noopener noreferrer"><code>이것이 있으면 그것이 있고, 이것이 생기기 때문에 그것이 생긴다. 이것이 없으면 그것이 없고, 이것이 멸하기 때문에 그것이 멸한다.</code></a></strong></p><p>조사를 마친 결과, 김 빠지는 결론일수도 있으나 둘의 구분을 짓는 건 무의미하다는 느낌이 들었고 연기같았다.</p><p>디자인 없이 아키텍처가 있을 수 없고, 아키텍처가 없이 디자인이 있을 수 없기 때문이다.</p><p>누군가 묻는다면 아키텍처는 고수준, 디자인은 구현 수준을 표현한다 말할 수 있겠지만...</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/architecture">architecture</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/design">design</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/감상">감상</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about 아키텍처와 디자인" href="/La-viva-es-Sueno/blog/difference-architecture-and-design"><b>Read More</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/La-viva-es-Sueno/blog/think-about-personal-developement-architecture">개인개발 / 스타트업이 선택하면 좋을 최강의 아키텍처에 대한 생각</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2022-04-07T00:00:00.000Z" itemprop="datePublished">April 7, 2022</time> · <!-- -->13 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_sTYa"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/rewrite0w0" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">rewrite0w0</span></a></div><small class="avatar__subtitle" itemprop="description">JavaScript 개발자</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><blockquote><p><a href="https://zenn.dev/yuno_miyako/articles/19201dcb19ff6b6ffc59" target="_blank" rel="noopener noreferrer">글</a></p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="결론">결론<a class="hash-link" href="#결론" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="https://storage.googleapis.com/zenn-user-upload/2v2eb15y29ueoa42tgz0x72vmlwx" alt="supa architecture" class="img_ev3q"></p><ul><li>Serverless Framework 사용.</li><li>프론트엔드는 S3 hosting + CloudFront, SSR도 Lambda@Edge로 가능.</li><li>DB는 RDS를 사용하지 말고, DynamoDB.</li><li>API는 기본적으로 GraphQL, 필요할 때 REST도 간단히 추가가능.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="배경-아키텍처에는-절대-정답이-없다">배경: 아키텍처에는 절대 정답이 없다<a class="hash-link" href="#배경-아키텍처에는-절대-정답이-없다" title="Direct link to heading">​</a></h2><p>아키텍처에는 절대 정답이 없다.
왜냐면 제품, 단계에 의해서 <strong>필요한 요건</strong>이 변하며, 그것을 고려해서 아키텍처를 생각할 필요가 있기 때문입니다.</p><p>예를 들어, 어떤 사건으로 1일 휴장했던 도쿄 증권 거래소 시스템은 <strong>안정성, 신뢰</strong>에 전력을 다해, 400대 서버에 부하 분산을 하거나, 네트워크 분산으로 장애 영향 범위를 국소화하는 아키텍처입니다.</p><p>AWS이나 メルカリ(mercari) 같은 기업은 <strong>확장성</strong>이 높고 이노베이션을 계속 일으킬 수 있도록 전체 애플리케이션에 영향을 끼치지 않고 새로운 서비스를 시도 가능한 마이크로 서비스 아키텍처를 사용중입니다.</p><p>그럼 개인개발, 스타트업은 어떤 요건을 중시해야할지 생각해봅시다.
<a href="https://www.idaten.vc/post/%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88%E3%82%A2%E3%83%83%E3%83%97%E3%81%8C%E5%A4%B1%E6%95%97%E3%81%99%E3%82%8B%E7%90%86%E7%94%B1%E3%83%88%E3%83%83%E3%83%9720" target="_blank" rel="noopener noreferrer">여기</a>에 스타트업이 실패하는 이유 순위가 있습니다.</p><p><strong><em>스타트업이 실패하는 이유 랭킹</em></strong></p><ol><li>시장 니즈가 없어서</li><li>자본 고갈</li><li>적절한 팀 구성 실패</li><li>경쟁력 패배</li><li>사용하기 어려운 제품</li></ol><p>전부 아키텍처 수준에서 해결 가능한 것은 아니지만, 어떤 요건이 필요한가 봅시다.</p><ol><li>시장 니즈가 없어서 =&gt; 고객의 기대에 맞춰 사양을 변화하기 좋은 <strong>민첩함</strong></li><li>자본 고갈 =&gt; <strong>비용 최적화</strong></li><li>적절한 팀 구성 실패 =&gt; 최대한 전문가가 필요로하지 않도록 <strong>작은 구성</strong></li><li>경쟁력 패배 =&gt; <strong>개발 속도</strong>를 올려 경합 상태 돌파</li><li>사용하기 어려운 제품 =&gt; 개선 사이클을 높이기 위한 <strong>민첩함</strong></li></ol><p>개인개발/스타트업에 필요한 요건은 <strong>민첩함, 비용 최적화, 작은 구성, 개발 속도</strong>가 아닐까 가설을 세웠습니다.
그럼 이 관점에서 기술 요소를 검토합시다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="기술요소">기술요소<a class="hash-link" href="#기술요소" title="Direct link to heading">​</a></h2><p>배경에서 개인개발과 스타트업에는 <strong>민첩함, 비용 최적화, 작은 구성, 개발 속도</strong>가 우수한 기술 요소를 선택해야 하지 않을까 검토했습니다.</p><p>이 관점에서 저는 우수하다 생각하는 기술요소를 소개하려합니다.
구성은 <code>프론트엔드</code>, <code>DB</code>, <code>백엔드(API)</code> 입니다.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="프론트엔드">프론트엔드<a class="hash-link" href="#프론트엔드" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="프론트엔드-프레임워크-선정">프론트엔드 프레임워크 선정<a class="hash-link" href="#프론트엔드-프레임워크-선정" title="Direct link to heading">​</a></h4><p>프론트엔드는 React, Vue, Angular 3대 프레임이 있습니다.
<strong><code>개발속도</code>, <code>민첩함</code> 관점으로 보면, TypeScript로 타입을 붙이는 것이 필수라 생각합니다. 입력 보완을 혜택을 받으면서 어떤 데이터를 받고 넘기면 되는가 한 눈에 알기 쉽기에 개발 효율을 올릴 수 있으면서, 사양변경이나 코드 변경할 때도 에러 체크를 컴파일할 때 알기 때문입니다.</strong>
<strong>그러니 TS와 상성이 좋다 관점에서 React</strong>가 군계일학이기에 프론트엔드 프레임워크는 <strong>React를 선택해야한다</strong> 생각합니다.</p><p>또한, <strong><code>개발속도</code>, <code>작은 구성</code> 관점에서는 저는 <code>React</code>보다 <code>Next.js</code> 사용하는 것을 추천</strong>합니다.
Next.js가 필요하지만 구현에 귀찮은 일을 <strong>No Config</strong>로 실현시켜주기 때문입니다. 구체적으로 말하면 루팅, SSR(SEO, SNG의 OGP를 위해서)입니다.
이상의 이유로 <strong>Next.js(TS)를 프레임워크로 추천</strong>합니다.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="프론트엔드-디플로이-할-곳">프론트엔드 디플로이 할 곳<a class="hash-link" href="#프론트엔드-디플로이-할-곳" title="Direct link to heading">​</a></h4><p>Next.js 디폴로이 할 곳으로 먼저 떠오르는 것이, vercel, Netlify, Heroku 등이 있습니다.
이들은 상당히 편하게 디플로이 가능하며, 기본무료로 이용할 수 있어 선택지에 들어가 있습니다.
하지만 무료에는 <strong>반드시 기능적 제한</strong>이 있기에, 규모가 있는 것을 전제한다면 AWS으로 구축하고 싶습니다.</p><p><strong>S3 hosting + CloudFront</strong>라면 AWS 무료 혜택으로 사용할 수 있고, 무료 혜택이 아니라더라 <strong>거의 무료</strong>입니다. (S3은 0.025USD/GB, CloudFront 0.114USD/10TB)</p><p>vercel 등의 서비스에서 유료 계정은 고정비가 들지만, AWS의 이 구성이면 onDemand한 과금이므로 <strong><code>비용 최적화</code> 관점에서 S3hosting + CloudFront를 추천합니다.</strong></p><p>프론트엔드 디플로이할 곳으로 EC2, ECS 등 서버를 사용하는 것은 <strong>민첩함, 비용 최적화, 작은 구성, 개발 속도</strong> 관점에서 논외라 생각합니다.</p><p>Next.js의 SSR은 Lambda@Edge로 행해지고 있습니다.
이 구성의 디플로이는 <strong>Serverless Framework</strong>를 사용함으로 No Config로 간단히 해결합니다.</p><p><a href="https://github.com/serverless-nextjs/serverless-next.js" target="_blank" rel="noopener noreferrer">serverless-nextjs</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="db">DB<a class="hash-link" href="#db" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="rds-vs-dynamodb">RDS vs DynamoDB<a class="hash-link" href="#rds-vs-dynamodb" title="Direct link to heading">​</a></h4><p>결론부터 말하면 <strong>무조건 DynamoDB를 선택하는 것을 추천</strong>합니다.
정확히 말하면 DynamoDB에서는 표현할 수 없는 자료구조, 복잡한 접근패턴이라면 RDS를 사용해야하지만, 초기 단계에는 DynamoDB로 만들다가 무리가 생기면 RDS와 병용하는 접근이 좋다 생각합니다.</p><p><strong><code>비용 최적화</code> 관점으로 말하면, Dynamo는 종량과금으로 되어있지만 RDS는 인스턴스 기동시간으로 과금됩니다. 또한 RDS + Lambda는 RDS Proxy 도입을 꼭 해야합니다. Aurora Serverless도 있지만, 이는 콜드 스타트가 치명적</strong>입니다.</p><p><strong><code>민첩함</code></strong> 관점에서는 Dynamo는 NoSQL이므로 스키마가 고정되어 있지 않아 사양 변경에 유연하게 대응할 수 있습니다. RDB는 테이블 간의 의존관계가 있기에 테이블을 버리기 어렵고, 마이그레이션이나 SQL로 다시 제작할 경우가 생깁니다.</p><p><strong><code>개발속도</code></strong> 관점에서는 Dynamo는 데이터베이스 기능 관리가 필요하지 않고, GraphQL과 상성이 좋음으로 개발효율을 올릴 수 있습니다.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="dynamodb-설계">DynamoDB 설계<a class="hash-link" href="#dynamodb-설계" title="Direct link to heading">​</a></h4><p>DynamoDB를 추천한다 했지만, <strong>RDB스럽게 DynamoDB를 설계하면 100% 벽에 막힙니다.</strong> Dynamo는 Join을 할 수 없으므로, Join이 필요하지 않게 테이블 설계를 할 필요가 있습니다.
RDB랑 NoSQL은 테이블 설계를 하는 방법이 전혀 다르므로, 여기에 반드시 초기 학습 비용을 들여야합니다.</p><p>추천링크를 붙이겠습니다.
<a href="https://pages.awscloud.com/rs/112-TZM-766/images/20190905_%E3%82%A4%E3%83%81%E3%81%8B%E3%82%89%E7%90%86%E8%A7%A3%E3%81%99%E3%82%8B%E3%82%B5%E3%83%BC%E3%83%8F%E3%82%99%E3%83%BC%E3%83%AC%E3%82%B9%E3%82%A2%E3%83%95%E3%82%9A%E3%83%AA%E9%96%8B%E7%99%BA-%E3%82%B5%E3%83%BC%E3%83%8F%E3%82%99%E3%83%BC%E3%83%AC%E3%82%B9%E3%82%A2%E3%83%95%E3%82%9A%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E5%90%91%E3%81%8D%E3%81%AEDB%20%E8%A8%AD%E8%A8%88%E3%83%98%E3%82%99%E3%82%B9%E3%83%88%E3%83%95%E3%82%9A%E3%83%A9%E3%82%AF%E3%83%86%E3%82%A3%E3%82%B9.pdf" target="_blank" rel="noopener noreferrer">서버레스 애플리케이션을 위한 DB 설계 모범사례</a>
<a href="https://dev.classmethod.jp/articles/reinvent-2019-report-cmy304-for-developer/" target="_blank" rel="noopener noreferrer">Amazon DynamoDB 데이터 모델링</a>
<a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/bp-general-nosql-design.html" target="_blank" rel="noopener noreferrer">DynamoDB를 위한 NoSQL 설계</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="백엔드api">백엔드(API)<a class="hash-link" href="#백엔드api" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="rest-vs-graphql">REST vs GraphQL<a class="hash-link" href="#rest-vs-graphql" title="Direct link to heading">​</a></h4><p><strong><code>민첩함</code>, <code>작은 구성</code>, <code>개발속도</code> 관점에서 GraphQL를 추천합니다.</strong></p><p>GraphQL은 지금까지 지니고 있었던 백엔드의 책무를 프론트엔드로 이양하는 측면이 있습니다.
그래서 UI 변경이 일어날 때마다 API 수정 할 필요가 없어져 <strong>민첩함이 상승합니다.</strong></p><p>또 Lambda로 REST API를 작성하면, 엔드포인트 수 만큼 Lambda를 만들어야합니다(이를 피하는 방법도 있긴 합니다.)만, GraphQL은 <strong>단일 엔드포인트이므로 <code>작은 구성</code>을 유지할 수 있습니다.</strong></p><p>GraphQL은 프론트엔드에서 이용할 때 사용하기 상당히 쉽고, 이는 체감이지만 REST보다 <strong>프론트엔드 개발 속도를 올려주는 기분입니다.</strong></p><p>그러나 REST가 더 우수하게 처리하는 것도 있습니다. 예를 들면 파일 업로드 등은 GraphQL로 하려하면, 상당히 공을 들여야합니다. 그럴 때는 REST 엔드포인트를 병용하면 됩니다. <strong>API Gateway</strong>를 사이에 두면, 같은 도메인으로 대응할 수 있습니다.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="디플로이에-대해">디플로이에 대해<a class="hash-link" href="#디플로이에-대해" title="Direct link to heading">​</a></h3><p>API Gateway + Lambda(GraphQL) + Lambda(REST) + DynamoDB 구성의 디플로이는 Serverless Framework를 사용하면 간단합니다.</p><p><a href="https://github.com/serverless/examples" target="_blank" rel="noopener noreferrer">여기</a>에 각 언어의 템플릿이 있으므로 찾아서, 디폴리이까지 해보시길 바랍니다. 간편함 놀랄 것이라 생각합니다.
여담으로 저는 <a href="https://github.com/serverless/serverless-graphql" target="_blank" rel="noopener noreferrer">이 템플릿</a>을 커스터마이즈해서 사용하기 쉽게 만들어 사용하고 있습니다.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="인증인가에-대해">인증인가에 대해<a class="hash-link" href="#인증인가에-대해" title="Direct link to heading">​</a></h3><p>인증인가는 로그인 기능 등을 구현할 때는 <strong>Cognito</strong>를 활용합니다. 개발 속도를 의식하면, 스스로 구현하는게 빠를 때도 있지만, 보안에 관한 것이므로 매니지드 서비스를 쓰는 것이 별 탈없겠죠.
이것도 Serverless Framework에 추가 가능합니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="재결론">재결론<a class="hash-link" href="#재결론" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="https://storage.googleapis.com/zenn-user-upload/2v2eb15y29ueoa42tgz0x72vmlwx" alt="recommend architecture for personal developer &amp; start up" class="img_ev3q"></p><p>이상을 정리하면 이러한 그림 구성이 됩니다.</p><ul><li>Serverless Framework 사용.</li><li>프론트엔드는 S3 hosting + CloudFront, SSR도 Lambda@Edge로 가능.</li><li>DB는 RDS를 사용하지 말고, DynamoDB.</li><li>API는 기본적으로 GraphQL, 필요할 때 REST도 간단히 추가가능.</li></ul><p>이게 포인트라 생각합니다.
개인개발 / 스타트업에 관련한 분이라면 참고가 될 것이라 생각합니다.</p><p>감사합니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/architecture">architecture</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/personal-developement">personal developement</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/start-up">start up</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/La-viva-es-Sueno/blog/tags/번역">번역</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about 개인개발 / 스타트업이 선택하면 좋을 최강의 아키텍처에 대한 생각" href="/La-viva-es-Sueno/blog/think-about-personal-developement-architecture"><b>Read More</b></a></div></footer></article><nav class="pagination-nav" aria-label="Blog list page navigation"></nav></main></div></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 rewrite0w0, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/La-viva-es-Sueno/assets/js/runtime~main.fccf6e12.js"></script>
<script src="/La-viva-es-Sueno/assets/js/main.2307e441.js"></script>
</body>
</html>